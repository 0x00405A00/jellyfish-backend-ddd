@implements IDisposable
@attribute [Route(RouteConst.Routes.DashBoard)]
@using Microsoft.AspNetCore.Http
@inject WebApiRestClient WebApiClient
@inject NavigationManager NavigationManager
@inject SignalRClient SignalRClient
@inject IJSRuntime JsRuntime
@inject IConfiguration Configuration
@inject LogoutBackgroundService LogoutBackgroundService
@inject CustomAuthentificationStateProvider AuthentificationService

<h3>Dashboard</h3>
<h3>Uhrzeit: @CurTime.ToLongTimeString()</h3>
<div class="d-flex flex-row">
    <div class="d-flex flex-column">

        <div>

            <MudChart ChartType="ChartType.Bar" onmouseover="@HoverChart" ChartSeries="@Series" XAxisLabels="@XAxisLabelsSeries" Width="100%" Height="350px"></MudChart>
        </div>
        <div>

            <MudChart ChartType="ChartType.Line" ChartSeries="@Series2" XAxisLabels="@XAxisLabelsSeries2" Width="100%" Height="350px"></MudChart>
        </div>
    </div>
    <div>

        <div>

            <MudChart ChartType="ChartType.Line" ChartSeries="@Series3" XAxisLabels="@XAxisLastHours" Width="100%" Height="350px"></MudChart>
        </div>
    </div>
</div>
<div class="table-container">
    <table>
        @foreach (var msg in Messages)
        {
            <tr>
                <td>@msg.Text</td>
            </tr>
        }
    </table>
    </div>


@code {
    private DateTime CurTime = DateTime.Now;
    private CancellationTokenSource cancellationToken = new();
    public List<MessageDTO> Messages = new List<MessageDTO>();
    public List<UserDTO> UsersList = new List<UserDTO>();
    public List<MailOutboxDTO> MailQueue = new List<MailOutboxDTO>();
    public List<ChartSeries> Series = new List<ChartSeries>()
    {
        new ChartSeries() { Name = "Neuregistrierungen", Data = new double[] { 0,0,0,0,0,0,0,0,0,0,0,0 } },
        new ChartSeries() { Name = "Neuregistrierungen Vormonat", Data = new double[] { 0,0,0,0,0,0,0,0,0,0,0,0 } },
    };
    public List<ChartSeries> Series2 = new List<ChartSeries>()
    {
        new ChartSeries() { Name = "Registrierung", Data = new double[] { 0,0,0,0,0,0,0,0,0,0,0,0 } },
        new ChartSeries() { Name = "Registrierung+Aktivierung", Data = new double[] { 0,0,0,0,0,0,0,0,0,0,0,0 } },
    };
    public List<ChartSeries> Series3 = new List<ChartSeries>()
    {
        new ChartSeries() { Name = "Ausgehende Mails", Data = new double[] { 0,0,0,0,0,0,0,0,0,0,0,0 } },//12*10 Min
    };
    public const int XAxisLastHoursBarCount = 12;
    private static string[] XAxisLabelsSeries = { "Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Okt", "Nov", "Dec" };
    private static string[] XAxisLabelsSeries2 = { "Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Okt", "Nov", "Dec" };
    private string[] XAxisLastHours = new string[XAxisLastHoursBarCount] { "", "", "", "", "", "", "", "", "", "", "", "" };

    public Dashboard()
    {
    }
    ~Dashboard()
    {


    }
    private void Dispose()
    {

        NavigationManager.LocationChanged -= LocationChangedEvent;
        LogoutBackgroundService.OnRerenderRequested -= RequestRerender;
        cancellationToken.Cancel();
        Series.Clear();
        Series2.Clear();
        Series3.Clear();
        UsersList.Clear();
        Messages.Clear();
        MailQueue.Clear();
        XAxisLastHours = null;
        GC.SuppressFinalize(this);
    }
    void IDisposable.Dispose()
    {
        Dispose();
    }
    protected override Task OnInitializedAsync()
    {
        return Task.CompletedTask;
    }
    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if(firstRender)
        {
            if (!SignalRClient.IsBuilded)
            {
                SignalRClient.BuildConnection();

            }
            if (SignalRClient.HubConnection.State != HubConnectionState.Connected)
                SignalRClient.OpenConnection();

            SignalRClient.HubConnection.On<List<MessageDTO>>(nameof(SignalRClient.ReceiveMessage), ReceiveMessage);
            NavigationManager.LocationChanged += LocationChangedEvent;
            for (int i = 0; i < XAxisLastHoursBarCount; i++)
            {
                var dt = DateTime.Now;
                var calcDt = (dt.AddMinutes(-(i * 10)));
                var calcTenMinSlot = (int)Math.Round((double)calcDt.Minute / 10) * 10;
                XAxisLastHours[XAxisLastHoursBarCount - 1 - i] = "" + calcDt.Hour.ToString().PadLeft(2, '0') + ":" + calcTenMinSlot.ToString().PadLeft(2, '0');
            }

            await GetData();
            LogoutBackgroundService.OnRerenderRequested += RequestRerender;
            StateHasChanged();
        }
    }
    private void LocationChangedEvent(object sender, LocationChangedEventArgs locationChangedEventArgs)
    {

        if (!locationChangedEventArgs.Location.EndsWith(RouteConst.Routes.DashBoard))
        {
            Dispose();
        }
    }
    private void RequestRerender()
    {
        InvokeAsync(()=>
        {
            CurTime = DateTime.Now;
            StateHasChanged(); // Dies löst einen Rerender der Komponente aus
        });
    }
    private async Task GetData()
    {
        var token = await AuthentificationService.GetCurrentAuthentification(cancellationToken.Token) ;
        var requestUsers = WebApiClient.Request < ApiDataTransferObject<List<UserDTO>>, object>("/user", RestSharp.Method.Get, cancellationToken.Token, null, headers: new List<KeyValuePair<string, string>>() { new KeyValuePair<string, string>("Authorization", token.Token) });


        var responseUsers = await requestUsers;
        if (responseUsers.IsSuccess)
        {
            UsersList = responseUsers.ApiResponseDeserialized.Data.Value;
            var onlyRegisteredAndNotActivated = UsersList.Where(x => x.CreatedTime.Value.Year == DateTime.Now.Year && x.ActivationDateTime==null).Select(x => x.CreatedTime).GroupBy(x => x.Value.Month);
            var newFullyRegisteredAccountThisYearCounts = UsersList.Where(x => x.ActivationDateTime != null && x.ActivationDateTime.Value.Year == DateTime.Now.Year).Select(x => x.ActivationDateTime).GroupBy(x => x.Value.Month);
            var fullyRegisteredAccountPreYearDecCount = UsersList.Where(x => x.ActivationDateTime != null&&x.ActivationDateTime.Value.Year == DateTime.Now.Year - 1 && x.ActivationDateTime.Value.Month == 12).Select(x => x.ActivationDateTime).Count();
            foreach (var statistic in newFullyRegisteredAccountThisYearCounts)
            {
                int preYear = DateTime.Now.Year - 1;
                int month = statistic.Key;
                int monthCount=statistic.Count();

                int preMonthCalc = ((month - 1 <= 0)?12:month-1);
                var preMonth = (newFullyRegisteredAccountThisYearCounts.Where(x => x.Key == (preMonthCalc)).Select(x => x).FirstOrDefault());

                int preMonthCount = preMonthCalc != 12 ? (preMonth != null ? preMonth.Count() : 0) : fullyRegisteredAccountPreYearDecCount;
                Series[0].Data[month-1] = monthCount;
                Series[1].Data[month - 1] = preMonthCount;
                Series2[1].Data[month - 1] = monthCount;
            }
            foreach (var statistic in onlyRegisteredAndNotActivated)
            {
                int month = statistic.Key;
                int monthCount = statistic.Count();
                Series2[0].Data[month - 1] = monthCount;
            }

        }


    }
    public Task HoverChart()
    {
        return Task.CompletedTask;
    }
    public Task ReceiveMessage(List<MessageDTO> messages)
    {
        Messages.AddRange(messages);
        InvokeAsync(StateHasChanged);
        return Task.CompletedTask;
    }
}
